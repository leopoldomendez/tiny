package compilador;

import java_cup.runtime.*;
import ast.*;

action code {:
	private boolean modoDepuracion=false;
	private NodoBase ast=null;
	private int lineanum=0;
	
	//Debe ser llamada solo despues de un parse(), en caso contrario retornara null siempre;
	public NodoBase getASTroot(){
		return ast;
	}
:}

/* Simbolos Terminales */

terminal IF;
terminal THEN;
terminal ELSE;
terminal BEGIN;
terminal END;
terminal REPEAT;
terminal UNTIL;
terminal READ;
terminal WRITE;
terminal String ID;
terminal Integer NUM;
terminal ASSIGN;
terminal EQ;
terminal LT;
terminal BT;
terminal MAYORIGUAL;
terminal MENORIGUAL;
terminal PLUS;
terminal MINUS;
terminal TIMES;
terminal OVER;
terminal LPAREN;
terminal RPAREN;
terminal LCORCHETE;
terminal RCORCHETE;
terminal SEMI;
terminal FOR;
terminal DIFERENTE;
terminal AND;
terminal OR;
terminal COLON;
terminal TRUE;
terminal FALSE;
terminal RETURN;
terminal VOID;
terminal INT;
terminal BOOLEAN;

/* Simbolos No Terminales */
non terminal program;
non terminal NodoBase function_list;
non terminal NodoBase function_stmt;
non terminal NodoBase stmt_seq;
non terminal NodoBase stmt;
non terminal NodoBase call_stmt;
non terminal NodoBase procedure_stmt;
non terminal NodoBase body;
non terminal NodoBase param_list;
non terminal NodoBase param_list2;
non terminal NodoBase for_stmt;
non terminal NodoBase if_stmt;
non terminal NodoBase repeat_stmt;
non terminal NodoBase assign_stmt;
non terminal NodoBase read_stmt;
non terminal NodoBase write_stmt;
non terminal NodoBase exp3;
non terminal NodoBase exp2;
non terminal NodoBase exp;
non terminal NodoBase simple_exp;
non terminal NodoBase term;
non terminal NodoBase factor;
non terminal NodoBase tipo;


/* Precedencia de operadores */
precedence left OR;
precedence left AND;
precedence left EQ,LT,BT,MAYORIGUAL,MENORIGUAL,DIFERENTE;
precedence left PLUS;
precedence left MINUS;
precedence left TIMES;
precedence left OVER;
precedence left LCORCHETE, RCORCHETE;
precedence left LPAREN, RPAREN;
precedence left LCORCHETE,RCORCHETE;
precedence left LPAREN, RPAREN;

/* REGLAS GRAMATICALES */

program
	::= function_list:ini body:pbody
		{:		
			NodoBase hijoActual = ini;
			
			ast = hijoActual;
						
			if(hijoActual!=null)
			{
				while(hijoActual.TieneHermano())
				{
					hijoActual = hijoActual.getHermanoDerecha();
				} 
				hijoActual.setHermanoDerecha(pbody);
				RESULT=ini;
			}else
			{
				ast = pbody;
			}					
		:}
	;

function_list
	::=	function_list:ini function_stmt:fest
		{:
			NodoBase hijoActual = ini;
			if(hijoActual!=null)
			{
				while(hijoActual.TieneHermano())
				{
					hijoActual = hijoActual.getHermanoDerecha();
				}
				hijoActual.setHermanoDerecha(fest);
				RESULT=ini;
			}else
			{
				RESULT=fest;
			}		
		:}
	|	function_stmt:fest
		{:
			RESULT = fest;					
		:}	
	|
		{:
			RESULT = null;		
		:}	
	;
	
function_stmt
	::=	tipo ID:variable LPAREN param_list:ini RPAREN body:pbody
		{:
			RESULT = new NodoFuncion(variable,ini,pbody);		
		:}	
	;		

stmt_seq
	::= stmt_seq:ini COLON stmt:sent SEMI
		{:
			NodoBase hijoActual = ini;
			if(hijoActual!=null)
			{
				while(hijoActual.TieneHermano())
				{
					hijoActual = hijoActual.getHermanoDerecha();
				}
				hijoActual.setHermanoDerecha(sent);
				RESULT=ini;
			}else
			{
				RESULT=sent;
			}		
		:}
	|	stmt:sent
		{:
			RESULT = sent;		
		:}
	|
		{:
			RESULT = null;		
		:}		
	;

stmt
	::= if_stmt:sif
		{:
			RESULT = sif;		
		:}
	|	repeat_stmt:srep
		{:
			RESULT = srep;		
		:}	
	|	assign_stmt:sasi
		{:
			RESULT = sasi;		
		:}	
	|	read_stmt:slec
		{:
			RESULT = slec;		
		:}	
	|	write_stmt:sesc
		{:
			RESULT = sesc;		
		:}	
	|	for_stmt:sfor
		{:
			RESULT = sfor;		
		:}	
	|	procedure_stmt:sproc
		{:
			RESULT = sproc;		
		:}	
	|	call_stmt:scall
		{:
			RESULT = scall;		
		:}	
	|	RETURN simple_exp:sexp
		{:
			if(sexp!=null)
			{
				RESULT = new sexp;		
			}else
			{
				RESULT = null;		
			}		
		:}	
	|	RETURN TRUE
		{:
			RESULT = TRUE;		
		:}		
	|	RETURN FALSE
		{:
			RESULT = FALSE;		
		:}			
	|	error
		{:
			RESULT = null;		
		:}
	;	

call_stmt 
	::= ID:variable LPAREN param_list:ini RPAREN
		{:
			if(variable!=null)
			{
				RESULT = new NodoLLamada(variable,ini);		
			}else
			{
				RESULT = null;		
			}		
		:}
	|	ID:variable1 EQ ID:variable2 LPAREN param_list:ini RPAREN
		{:
			if(variable!=null)
			{
				RESULT = new NodoLLamada(variable1,variable2,ini);		
			}else
			{
				RESULT = null;		
			}		
		:}	
	;

procedure_stmt
	::= VOID ID:variable LPAREN param_list2:ini RPAREN body:pbody
		{:
			RESULT = new NodoProcedimiento(variable,ini,pbody);		
		:}
	|	INT  ID:variable LPAREN param_list2:ini RPAREN body:pbody
		{:
			RESULT = new NodoProcedimiento(variable,ini,pbody);		
		:}
	|	BOOLEAN ID:variable LPAREN param_list2:ini RPAREN body:pbody
		{:
			RESULT = new NodoProcedimiento(variable,ini,pbody);		
		:}		
	;

body
	::= BEGIN stmt_seq:pbody END
		{:
			RESULT = pbody;		
		:}
	;

param_list
	::= param_list:ini COLON INT ID:variable
		{:	
			NodoBase hijoActual = ini;
			if(hijoActual!=null)
			{
				while(hijoActual.TieneHermano())
				{
					hijoActual = hijoActual.getHermanoDerecha();
				}
				hijoActual.setHermanoDerecha(variable);
				RESULT=ini;
			}else
			{
				RESULT=variable;
			}		
		:}
	|	INT ID:variable
		{:
			if(variable!=null)
			{
				RESULT= new NodoIdentificador(variable.toString());			
			}else
			{
				RESULT = null;		
			}		
		:}	
	|  
		{:
			RESULT = null;		
		:}
	;	
	
param_list2
	::= param_list2:ini COLON exp:ex
		{:	
			NodoBase hijoActual = ini;
			if(hijoActual!=null)
			{
				while(hijoActual.TieneHermano())
				{
					hijoActual = hijoActual.getHermanoDerecha();
				}
				hijoActual.setHermanoDerecha(ex);
				RESULT=ini;
			}else
			{
				RESULT=ex;
			}		
		:}
	|	exp:ex
		{:
			RESULT = ex;		
		:}	
	|  
		{:
			RESULT = null;		
		:}
	;	

for_stmt
	::= FOR LPAREN assign_stmt:pasig SEMI exp:pcomprob SEMI assign_stmt:ppaso RPAREN stmt_seq:pcuerpo END
		{:
			RESULT = new NodoFor(pasig,pcomprob,ppaso,pcuerpo);		
		:}
	;	

if_stmt
	::= IF exp2:ex THEN stmt_seq:pthen END
		{:
			RESULT = new NodoIf(ex,pthen);		
		:}
	|	IF exp2:ex THEN stmt_seq:pthen ELSE stmt_seq:pelse END
		{:
			RESULT = new NodoIf(ex,pthen,pelse);		
		:}	
	;

repeat_stmt
	::= REPEAT stmt_seq:exI UNTIL exp3:exD
		{:
			RESULT = new NodoRepeat(exI,exD);		
		:}
	;

assign_stmt
	::= ID:variable ASSIGN exp3:ex
		{:
			if(variable!=null)
			{
				RESULT = new NodoAsignacion(variable.toString(),ex);							
			}else
			{
				RESULT = null;			
			}		
		:}
	; 

read_stmt
	::= READ ID:variable
		{:
			if(variable!=null)
			{
				RESULT= new NodoLeer(variable.toString());			
			}else
			{
				RESULT = null;			
			} 		
		:}
	;

write_stmt
	::=	WRITE exp3:ex
		{:
			RESULT = new NodoEscribir(ex);		
		:}
	;

exp3
	::= exp3:exI OR  exp2:exD
		{:
			RESULT = new NodoOperacion(exI,tipoOp.or,exD);		
		:}
	|	exp3:exI AND exp2:exD
		{:
			RESULT = new NodoOperacion(exI,tipoOp.and,exD);		
		:}	
	|	exp2:ex
		{:
			RESULT = ex;		
		:}
	;	

exp2
	::= exp2:exI EQ 		exp:exD
		{:
			RESULT = new NodoOperacion(exI,tipoOp.igual,exD);		
		:}
	|	exp2:exI DIFERENTE  exp:exD
		{:
			RESULT = new NodoOperacion(exI,tipoOp.diferente,exD);		
		:}	
	|	exp:ex
		{:
			RESULT = ex;
		:}
	;

exp
	::= simple_exp:exI LT	 	  simple_exp:exD
		{:
			RESULT = new NodoOperacion(exI,tipoOp.menor,exD);		
		:}	
	|	simple_exp:exI BT 		  simple_exp:exD
		{:
			RESULT = new NodoOperacion(exI,tipoOp.mayor,exD);		
		:}	
	|	simple_exp:exI MENORIGUAL simple_exp:exD
		{:
			RESULT = new NodoOperacion(exI,tipoOp.menorigual,exD);		
		:}	
	|	simple_exp:exI MAYORIGUAL simple_exp:exD
		{:
			RESULT = new NodoOperacion(exI,tipoOp.mayorigual,exD);		
		:}					
	|	simple_exp:ex
		{:
			RESULT = ex;		
		:}
	;	

simple_exp
	::= simple_exp:exI PLUS  term:exD
		{:
			RESULT = new NodoOperacion(exI,tipoOp.mas,exD);		
		:}
	|  	simple_exp:exI MINUS term:exD
		{:
			RESULT = new NodoOperacion(exI,tipoOp.menos,exD);		
		:}		
	|	term:ex
		{:
			RESULT = ex;		
		:}
	;	
		
term
	::= term:exI TIMES factor:exD
		{:
			RESULT = new NodoOperacion(exI,tipoOp.por,exD);
		:}		
	|	term:exI OVER  factor:exD
		{:
			RESULT = new NodoOperacion(exI,tipoOp.entre,exD);		
		:}		
	|	factor:ex
		{:
			RESULT = ex;		
		:} 
	;	
		
factor
	::= LPAREN exp:e RPAREN
		{:
			RESULT = e;
		:}	
	|	NUM:valor
		{:
			if(valor!=null)
			{
				RESULT = new NodoValor(valor);			
			}else
			{
				RESULT = null;		
			}	
		:}
	|	ID:variable
		{:
			if(variable!=null)
			{
				RESULT= new NodoIdentificador(variable.toString());			
			}else
			{
				RESULT = null;		
			}	
		:}
	| ID:variable LCORCHETE simple_exp:e RCORCHETE 
		{:
			RESULT = new NodoVector(variable,e);
		:} 		
	| error
		{:
			RESULT = null;
		:}
	;
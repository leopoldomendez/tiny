package compilador;

import java_cup.runtime.*;
import ast.*;

action code {:
	private boolean modoDepuracion=false;
	private NodoBase ast=null;
	private int lineanum=0;
	
	//Debe ser llamada solo despues de un parse(), en caso contrario retornara null siempre;
	public NodoBase getASTroot(){
		return ast;
	}
:}

/* Simbolos Terminales */

terminal IF;
terminal THEN;
terminal ELSE;
terminal BEGIN;
terminal END;
terminal REPEAT;
terminal UNTIL;
terminal READ;
terminal WRITE;
terminal String ID;
terminal Integer NUM;
terminal ASSIGN;
terminal EQ;
terminal LT;
terminal BT;
terminal MAYORIGUAL;
terminal MENORIGUAL;
terminal PLUS;
terminal MINUS;
terminal TIMES;
terminal OVER;
terminal LPAREN;
terminal RPAREN;
terminal LCORCHETE;
terminal RCORCHETE;
terminal SEMI;
terminal FOR;
terminal DIFERENTE;
terminal AND;
terminal OR;
terminal COLON;
terminal TRUE;
terminal FALSE;
terminal RETURN;
terminal INT;
terminal VOID;
terminal BOOLEAN;

/* Simbolos No Terminales */
non terminal program;
non terminal NodoBase function_list;
non terminal NodoBase function_stmt;
non terminal NodoBase stmt_seq;
non terminal NodoBase stmt;
non terminal NodoBase call_stmt;
non terminal NodoBase procedure_stmt;
non terminal NodoBase body;
non terminal NodoBase param_list;
non terminal NodoBase param_list2;
non terminal NodoBase for_stmt;
non terminal NodoBase if_stmt;
non terminal NodoBase repeat_stmt;
non terminal NodoBase assign_stmt;
non terminal NodoBase read_stmt;
non terminal NodoBase write_stmt;
non terminal NodoBase exp3;
non terminal NodoBase exp2;
non terminal NodoBase exp;
non terminal NodoBase simple_exp;
non terminal NodoBase term;
non terminal NodoBase factor;
non terminal NodoBase tipo;


/* Precedencia de operadores */
precedence left OR;
precedence left AND;
precedence left EQ,LT,BT,MAYORIGUAL,MENORIGUAL,DIFERENTE;
precedence left PLUS;
precedence left MINUS;
precedence left TIMES;
precedence left OVER;
precedence left  ELSE;
precedence left LCORCHETE, RCORCHETE;
precedence left LPAREN, RPAREN;
precedence left LCORCHETE,RCORCHETE;
precedence left LPAREN, RPAREN;

/* REGLAS GRAMATICALES */

program
	::= function_list:ini body:pbody
		{:	
			if(debug) System.out.println("\t regla 1: programa");
				
			NodoBase hijoActual = ini;
						
			if(hijoActual!=null)
			{
				while(hijoActual.TieneHermano())
				{
					hijoActual = hijoActual.getHermanoDerecha();
				} 
				hijoActual.setHermanoDerecha(pbody);
				
				ast = ini;
			}else
			{
				ast = pbody;
			}					
		:}
	;

function_list
	::=	function_list:ini function_stmt:fest
		{:
			if(debug) System.out.println("\t regla 2: secuencia de sentencias 1");
		
			NodoBase hijoActual = ini;
			if(hijoActual!=null)
			{
				while(hijoActual.TieneHermano())
				{
					hijoActual = hijoActual.getHermanoDerecha();
				}
				hijoActual.setHermanoDerecha(fest);
				RESULT=ini;
			}else
			{
				RESULT=fest;
			}		
		:}
	|	function_stmt:fest
		{:
			if(debug) System.out.println("\t regla 2: secuencia de sentencias 2");
			
			RESULT = fest;					
		:}	
	|
		{:
			if(debug) System.out.println("\t regla 2: secuencia de sentencias epsilon");
			
			RESULT = null;		
		:}	
	;
	
function_stmt
	::=	tipo ID:variable LPAREN param_list:ini RPAREN body:pbody
		{:
			if(debug) System.out.println("\t regla 3: función");
		
			RESULT = new NodoFuncion(variable,ini,pbody);		
		:}	
	;		

stmt_seq
	::= stmt_seq:ini stmt:sent SEMI
		{:
			if(debug) System.out.println("\t regla 4: secuencia de sentencias 1");
		
			NodoBase hijoActual = ini;
			if(hijoActual!=null)
			{
				while(hijoActual.TieneHermano())
				{
					hijoActual = hijoActual.getHermanoDerecha();
				}
				hijoActual.setHermanoDerecha(sent);
				RESULT=ini;
			}else
			{
				RESULT=sent;
			}		
		:}
	|	stmt:sent SEMI
		{:
			if(debug) System.out.println("\t regla 4: secuencia de sentencias 2");
		
			RESULT = sent;		
		:}	
	;

stmt
	::= if_stmt:sif
		{:
			if(debug) System.out.println("\t regla sentencia if");
			
			RESULT = sif;		
		:}
	|	repeat_stmt:srep
		{:
			if(debug) System.out.println("\t regla sentencia repeat");
		
			RESULT = srep;		
		:}	
	|	assign_stmt:sasi
		{:
			if(debug) System.out.println("\t regla sentencia asignación");
			
			RESULT = sasi;		
		:}	
	|	read_stmt:slec
		{:
			if(debug) System.out.println("\t regla sentencia leer");
		
			RESULT = slec;		
		:}	
	|	write_stmt:sesc
		{:
			if(debug) System.out.println("\t regla sentencia escribir");
		
			RESULT = sesc;		
		:}	
	|	for_stmt:sfor
		{:
			if(debug) System.out.println("\t regla sentencia for");
		
			RESULT = sfor;		
		:}	
	|	procedure_stmt:sproc
		{:
			if(debug) System.out.println("\t regla sentencia procedimiento");
		
			RESULT = sproc;		
		:}	
	|	call_stmt:scall
		{:
			if(debug) System.out.println("\t regla 3: llamada de función");
		
			RESULT = scall;		
		:}	
	|	RETURN simple_exp:sexp
		{:
			if(debug) System.out.println("\t regla 8: return de expresion simple");
		
			RESULT =  sexp;				
		:}	
	|	RETURN TRUE
		{:
			if(debug) System.out.println("\t regla 8: return true");
		
			RESULT = new NodoBoolean(true);		
		:}		
	|	RETURN FALSE
		{:
			if(debug) System.out.println("\t regla 8: return false");
		
			RESULT = new NodoBoolean(false);		
		:}	
	|	error
		{:
			if(debug) System.out.println("\t regla 9: error de sentencia");
		
			RESULT = null;		
		:}				
	;	

call_stmt 
	::= ID:variable LPAREN param_list:ini RPAREN
		{:
			if(debug) System.out.println("\t regla 3: llamada de función");
		
			if(variable!=null)
			{
				RESULT = new NodoLLamada(variable,ini);		
			}else
			{
				RESULT = null;		
			}		
		:}
	|	ID:variable1 EQ ID:variable2 LPAREN param_list:ini RPAREN
		{:
			if(debug) System.out.println("\t regla 3: llamada de funcion función con asignación");
		
			if(variable1!=null && variable1!=null)
			{
				RESULT = new NodoLLamada(variable1,variable2,ini);		
			}else
			{
				RESULT = null;		
			}		
		:}	
	;

procedure_stmt
	::= tipo ID:variable LPAREN param_list2:ini RPAREN body:pbody
		{:
			if(debug) System.out.println("\t regla 10: procedimiento");
		
			RESULT = new NodoProcedimiento(variable,ini,pbody);		
		:}		
	;

body
	::= BEGIN stmt_seq:pbody END
		{:
			if(debug) System.out.println("\t regla 11: cuerpo con sentencias");
		
			RESULT = pbody;		
		:}
	;	

param_list
	::= param_list:ini COLON INT ID:variable
		{:
			if(debug) System.out.println("\t regla 12: dos o mas parametros");
			
			NodoBase hijoActual = ini;
			if(hijoActual!=null)
			{
				while(hijoActual.TieneHermano())
				{
					hijoActual = hijoActual.getHermanoDerecha();
				}
				
				hijoActual.setHermanoDerecha( new NodoIdentificador( variable.toString() ) );
				RESULT=ini;
			}else
			{
				RESULT = new NodoIdentificador(variable.toString());
			}		
		:}
	|	INT ID:variable
		{:
			if(debug) System.out.println("\t regla 12: un solo parametro");
		
			if(variable!=null)
			{
				RESULT= new NodoIdentificador(variable.toString());			
			}else
			{
				RESULT = null;		
			}		
		:}	
	|  
		{:
			if(debug) System.out.println("\t regla 12: funcion sin parametros");
		
			RESULT = null;		
		:}
	;	
	
param_list2
	::= param_list2:ini COLON exp:ex
		{:	
			if(debug) System.out.println("\t regla 13: dos o mas parametros de procedimiento");
		
			NodoBase hijoActual = ini;
			if(hijoActual!=null)
			{
				while(hijoActual.TieneHermano())
				{
					hijoActual = hijoActual.getHermanoDerecha();
				}
				hijoActual.setHermanoDerecha(ex);
				RESULT=ini;
			}else
			{
				RESULT=ex;
			}		
		:}
	|	exp:ex
		{:
			if(debug) System.out.println("\t regla 13: un parametro de procedimiento");
		
			RESULT = ex;		
		:}	
	|  
		{:
			if(debug) System.out.println("\t regla 13: procedimiento sin parametros");
			
			RESULT = null;		
		:}
	;	

for_stmt
	::= FOR LPAREN assign_stmt:pasig SEMI exp:pcomprob SEMI assign_stmt:ppaso RPAREN stmt_seq:pcuerpo END
		{:
			if(debug) System.out.println("\t regla sentencia for interna");
		
			RESULT = new NodoFor(pasig,pcomprob,ppaso,pcuerpo);		
		:}
	;	

if_stmt
	::= IF exp2:ex THEN stmt_seq:pthen END
		{:
			if(debug) System.out.println("\t regla sentencia if interna");
		
			RESULT = new NodoIf(ex,pthen);		
		:}
	|	IF exp2:ex THEN stmt_seq:pthen ELSE stmt_seq:pelse END
		{:
			if(debug) System.out.println("\t regla sentencia if interna con else");
		
			RESULT = new NodoIf(ex,pthen,pelse);		
		:}	
	;

repeat_stmt
	::= REPEAT stmt_seq:exI UNTIL exp3:exD
		{:
			if(debug) System.out.println("\t regla sentencia repeat interna");
		
			RESULT = new NodoRepeat(exI,exD);		
		:}
	;

assign_stmt
	::= ID:variable ASSIGN exp3:ex
		{:
			if(debug) System.out.println("\t regla sentencia asignacion interna");
		
			if(variable!=null)
			{
				RESULT = new NodoAsignacion(variable.toString(),ex);							
			}else
			{
				RESULT = null;			
			}		
		:}
	; 

read_stmt
	::= READ ID:variable
		{:
			if(debug) System.out.println("\t regla sentencia lectura interna");
		
			if(variable!=null)
			{
				RESULT= new NodoLeer(variable.toString());			
			}else
			{
				RESULT = null;			
			} 		
		:}
	;

write_stmt
	::=	WRITE exp3:ex
		{:
			if(debug) System.out.println("\t regla sentencia escritura interna");
		
			RESULT = new NodoEscribir(ex);		
		:}
	;

exp3
	::= exp3:exI OR  exp2:exD
		{:
			if(debug) System.out.println("\t regla operacion OR");
		
			RESULT = new NodoOperacion(exI,tipoOp.or,exD);		
		:}
	|	exp3:exI AND exp2:exD
		{:
			if(debug) System.out.println("\t regla operacion AND");
		
			RESULT = new NodoOperacion(exI,tipoOp.and,exD);		
		:}	
	|	exp2:ex
		{:
			if(debug) System.out.println("\t regla derivacion exp3 a exp2");
		
			RESULT = ex;		
		:}
	;	

exp2
	::= exp2:exI EQ 		exp:exD
		{:
			if(debug) System.out.println("\t regla operacion igualdad");
		
			RESULT = new NodoOperacion(exI,tipoOp.igual,exD);		
		:}
	|	exp2:exI DIFERENTE  exp:exD
		{:
			if(debug) System.out.println("\t regla operacion diferente");
		
			RESULT = new NodoOperacion(exI,tipoOp.diferente,exD);		
		:}	
	|	exp:ex
		{:
			if(debug) System.out.println("\t regla derivacion exp2 a exp");
		
			RESULT = ex;
		:}
	;

exp
	::= simple_exp:exI LT	 	  simple_exp:exD
		{:
			if(debug) System.out.println("\t regla operacion menor que");
		
			RESULT = new NodoOperacion(exI,tipoOp.menor,exD);		
		:}	
	|	simple_exp:exI BT 		  simple_exp:exD
		{:
			if(debug) System.out.println("\t regla operacion mayor que");
		
			RESULT = new NodoOperacion(exI,tipoOp.mayor,exD);		
		:}	
	|	simple_exp:exI MENORIGUAL simple_exp:exD
		{:
			if(debug) System.out.println("\t regla operacion menor o igual que");
		
			RESULT = new NodoOperacion(exI,tipoOp.menorigual,exD);		
		:}	
	|	simple_exp:exI MAYORIGUAL simple_exp:exD
		{:
			if(debug) System.out.println("\t regla operacion mayor o igual que");
		
			RESULT = new NodoOperacion(exI,tipoOp.mayorigual,exD);		
		:}					
	|	simple_exp:ex
		{:
			if(debug) System.out.println("\t regla operacion derivacion expresion a expresion simple");
		
			RESULT = ex;		
		:}
	;	

simple_exp
	::= simple_exp:exI PLUS  term:exD
		{:
			if(debug) System.out.println("\t regla operacion SUMA");
		
			RESULT = new NodoOperacion(exI,tipoOp.mas,exD);		
		:}
	|  	simple_exp:exI MINUS term:exD
		{:
			if(debug) System.out.println("\t regla operacion RESTA");
		
			RESULT = new NodoOperacion(exI,tipoOp.menos,exD);		
		:}		
	|	term:ex
		{:
			if(debug) System.out.println("\t regla operacion derivacion expresion simple a termino");
		
			RESULT = ex;		
		:}
	;	
		
term
	::= term:exI TIMES factor:exD
		{:
			if(debug) System.out.println("\t regla operacion MULTIPLICACION");
		
			RESULT = new NodoOperacion(exI,tipoOp.por,exD);
		:}		
	|	term:exI OVER  factor:exD
		{:
			if(debug) System.out.println("\t regla operacion DIVISION");
		
			RESULT = new NodoOperacion(exI,tipoOp.entre,exD);		
		:}		
	|	factor:ex
		{:
			if(debug) System.out.println("\t regla operacion derivacion termino a factor");
		
			RESULT = ex;		
		:} 
	;	
		
factor
	::= LPAREN exp:e RPAREN
		{:
			if(debug) System.out.println("\t regla factor a expresion entre parentesis");
			
			RESULT = e;
		:}	
	|	NUM:valor
		{:
			if(debug) System.out.println("\t regla valor numerico");
		
			if(valor!=null)
			{
				RESULT = new NodoValor(valor);			
			}else
			{
				RESULT = null;		
			}	
		:}
	|	ID:variable
		{:
			if(debug) System.out.println("\t regla identificador");
		
			if(variable!=null)
			{
				RESULT= new NodoIdentificador(variable.toString());			
			}else
			{
				RESULT = null;		
			}	
		:}
	| ID:variable LCORCHETE simple_exp:e RCORCHETE 
		{:
			if(debug) System.out.println("\t regla vector");
		
			RESULT = new NodoVector(variable,e);
		:} 		
	| error
		{:
			if(debug) System.out.println("\t regla error en factor");
		
			RESULT = null;
		:}
	;